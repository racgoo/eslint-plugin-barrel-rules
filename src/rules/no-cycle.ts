//This rule is generated by AI.
//Needs some tunning and proving.
//Beta version.
//If you have any suggestions, please let me know.

import { TSESTree } from "@typescript-eslint/types";
import type { RuleModule } from "@typescript-eslint/utils/ts-eslint";
import path from "path";
import fs from "fs";
import resolve from "resolve";
import { Alias } from "../utils/alias";
import {
  BARREL_ENTRY_POINT_FILE_NAMES,
  RESOLVE_EXTENSIONS,
} from "../utils/constants";

// ============================================================================
// Types
// ============================================================================

type MessageId =
  | "CircularDependency"
  | "BarrelInternalImportDisallowed"
  | "TransformedAliasResolveFailed";

// ============================================================================
// Global State (for tracking imports across files)
// ============================================================================

/** Import graph: file -> files it imports */
const importGraph = new Map<string, Set<string>>();

/** Cache: barrel file -> modules it exports */
const barrelExportsCache = new Map<string, string[]>();

// Export for testing
export { importGraph, barrelExportsCache };

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Check if a file is a barrel file (index.ts, index.js, etc.)
 */
function isBarrelFile(filePath: string): boolean {
  const fileName = path.basename(filePath);
  return BARREL_ENTRY_POINT_FILE_NAMES.includes(
    fileName as (typeof BARREL_ENTRY_POINT_FILE_NAMES)[number]
  );
}

/**
 * Check if an import path is an external package (node_modules)
 */
function isExternalImport(rawPath: string): boolean {
  // Bare imports like "react", "@emotion/react"
  if (!rawPath.startsWith(".") && !rawPath.startsWith("/")) {
    return true;
  }
  // Explicit node_modules path
  if (rawPath.includes("/node_modules/")) {
    return true;
  }
  return false;
}

/**
 * Resolve an import path to absolute path
 * Returns null for external imports or unresolvable paths
 */
function resolveImportPath(
  rawImportPath: string,
  currentFileDir: string
): string | null {
  try {
    // Try alias resolution first
    const aliasResult = Alias.resolvePath(rawImportPath, currentFileDir);

    if (aliasResult.type === "success") {
      return resolveAliasPath(aliasResult.absolutePath, currentFileDir);
    }

    // Alias failed - check if external
    if (isExternalImport(rawImportPath)) {
      return null;
    }

    // Resolve relative path
    return resolve.sync(rawImportPath, {
      basedir: currentFileDir,
      extensions: RESOLVE_EXTENSIONS,
    });
  } catch {
    return null;
  }
}

/**
 * Resolve an alias-resolved path (may be directory -> index.ts)
 */
function resolveAliasPath(
  resolvedPath: string,
  currentFileDir: string
): string {
  try {
    // Check if it's a directory
    const stats = fs.statSync(resolvedPath);
    if (stats.isDirectory()) {
      // Resolve to index.ts inside directory
      return resolve.sync("index", {
        basedir: resolvedPath,
        extensions: RESOLVE_EXTENSIONS,
      });
    }
    return resolvedPath;
  } catch {
    // Path doesn't exist as-is, try with extensions
    try {
      return resolve.sync(resolvedPath, {
        basedir: currentFileDir,
        extensions: RESOLVE_EXTENSIONS,
      });
    } catch {
      return resolvedPath;
    }
  }
}

/**
 * Get modules exported from a barrel file by analyzing its AST
 */
function getBarrelExports(
  barrelFileDir: string,
  ast: TSESTree.Program
): string[] {
  const exports: string[] = [];

  for (const statement of ast.body) {
    // export { ... } from "./path" or export * from "./path"
    if (
      (statement.type === "ExportNamedDeclaration" ||
        statement.type === "ExportAllDeclaration") &&
      statement.source
    ) {
      const exportPath = statement.source.value as string;
      const resolved = tryResolve(exportPath, barrelFileDir);
      if (resolved && !exports.includes(resolved)) {
        exports.push(resolved);
      }
    }

    // import { ... } from "./path" (barrel files often re-export imports)
    if (statement.type === "ImportDeclaration" && statement.source) {
      const importPath = statement.source.value as string;
      // Only relative imports (not external)
      if (importPath.startsWith(".") || importPath.startsWith("/")) {
        const resolved = tryResolve(importPath, barrelFileDir);
        if (resolved && !exports.includes(resolved)) {
          exports.push(resolved);
        }
      }
    }
  }

  return exports;
}

/**
 * Try to resolve a path, return null on failure
 */
function tryResolve(importPath: string, basedir: string): string | null {
  try {
    return resolve.sync(importPath, {
      basedir,
      extensions: RESOLVE_EXTENSIONS,
    });
  } catch {
    return null;
  }
}

// ============================================================================
// Cycle Detection
// ============================================================================

/**
 * DFS to detect cycles in the import graph
 * Returns the cycle path if found, null otherwise
 */
function detectCycle(
  startFile: string,
  visited: Set<string>,
  recStack: Set<string>,
  currentPath: string[]
): string[] | null {
  visited.add(startFile);
  recStack.add(startFile);
  currentPath.push(startFile);

  const imports = importGraph.get(startFile) || new Set();

  for (const importedFile of imports) {
    if (!visited.has(importedFile)) {
      // Not visited yet - recurse
      const cycle = detectCycle(importedFile, visited, recStack, [
        ...currentPath,
      ]);
      if (cycle) return cycle;
    } else if (recStack.has(importedFile)) {
      // Already in recursion stack - cycle found!
      const cycleStart = currentPath.indexOf(importedFile);
      return [...currentPath.slice(cycleStart), importedFile];
    }
  }

  recStack.delete(startFile);
  return null;
}

/**
 * Check for immediate bidirectional cycle (A -> B and B -> A)
 */
function hasBidirectionalCycle(fileA: string, fileB: string): boolean {
  const bImports = importGraph.get(fileB);
  return bImports?.has(fileA) ?? false;
}

/**
 * Check for cycle through barrel file exports
 */
function hasCycleThroughBarrel(
  currentFile: string,
  exportedModules: string[]
): string | null {
  for (const exportedModule of exportedModules) {
    if (exportedModule === currentFile) continue;

    const moduleImports = importGraph.get(exportedModule);
    if (moduleImports?.has(currentFile)) {
      return exportedModule;
    }
  }
  return null;
}

// ============================================================================
// Rule Definition
// ============================================================================

const noCycle: RuleModule<MessageId> = {
  meta: {
    type: "problem",
    docs: {
      description:
        "Detect circular dependencies and enforce relative imports in barrel files.",
    },
    schema: [],
    messages: {
      CircularDependency:
        "Circular dependency detected: {{cyclePath}}. This creates a dependency cycle that can cause runtime errors and make code harder to maintain.",
      BarrelInternalImportDisallowed:
        "Barrel files (index.ts) must use relative imports (./ or ../) for internal modules. Importing via barrel file or absolute path is not allowed. Use relative path: '{{relativePath}}'",
      TransformedAliasResolveFailed:
        "Transformed alias resolve failed. please check the alias config.",
    },
  },

  defaultOptions: [],

  create(context) {
    const currentFile = context.getFilename();
    const currentDir = path.dirname(currentFile);

    // Initialize or reset imports for current file
    if (!importGraph.has(currentFile)) {
      importGraph.set(currentFile, new Set());
    }
    importGraph.get(currentFile)!.clear();

    // Cache barrel file exports
    if (isBarrelFile(currentFile)) {
      const ast = context.getSourceCode().ast;
      const exports = getBarrelExports(currentDir, ast);
      barrelExportsCache.set(currentFile, exports);
    }

    // ========================================================================
    // Import/Export Checker
    // ========================================================================

    function checkImport(
      node:
        | TSESTree.ImportDeclaration
        | TSESTree.ExportNamedDeclaration
        | TSESTree.ExportAllDeclaration
    ) {
      if (!node.source) return;

      const rawPath = node.source.value as string;
      const absolutePath = resolveImportPath(rawPath, currentDir);

      // Skip external or unresolvable imports
      if (!absolutePath) return;

      // Rule 1: Barrel files must use relative imports for internal modules
      if (isBarrelFile(currentFile)) {
        const error = checkBarrelInternalImport(rawPath, absolutePath);
        if (error) {
          context.report({
            node,
            messageId: "BarrelInternalImportDisallowed",
            data: { relativePath: error },
          });
          return;
        }
      }

      // Rule 2: Cycle detection
      const isBarrelInternal =
        isBarrelFile(currentFile) &&
        absolutePath.startsWith(currentDir + path.sep);

      // Add to import graph
      addToGraph(absolutePath);

      // Skip cycle detection for barrel importing its own modules
      if (isBarrelInternal) return;

      // Check for cycles
      const cycleError = checkForCycles(absolutePath);
      if (cycleError) {
        context.report({
          node,
          messageId: "CircularDependency",
          data: { cyclePath: cycleError },
        });
      }
    }

    /**
     * Check if barrel file is using non-relative import for internal module
     * Returns suggested relative path if error, null if ok
     */
    function checkBarrelInternalImport(
      rawPath: string,
      absolutePath: string
    ): string | null {
      const isInternal =
        absolutePath.startsWith(currentDir + path.sep) ||
        absolutePath === currentDir;

      if (!isInternal) return null;

      // Internal module must use relative import
      if (rawPath.startsWith("./") || rawPath.startsWith("../")) {
        return null;
      }

      // Calculate suggested relative path
      const relative = path.relative(currentDir, absolutePath);
      const suggested = relative.startsWith(".") ? relative : `./${relative}`;
      return suggested.replace(/\\/g, "/");
    }

    /**
     * Add import to graph, including barrel file exports
     */
    function addToGraph(absolutePath: string) {
      const imports = importGraph.get(currentFile)!;
      imports.add(absolutePath);

      // If importing barrel file, also add its exports
      if (isBarrelFile(absolutePath)) {
        const exports = barrelExportsCache.get(absolutePath) || [];
        for (const exp of exports) {
          if (exp !== currentFile) {
            imports.add(exp);
          }
        }
      }
    }

    /**
     * Check for circular dependencies
     * Returns cycle path string if found, null otherwise
     */
    function checkForCycles(absolutePath: string): string | null {
      // Check barrel file cycle first
      if (isBarrelFile(absolutePath)) {
        const exports = barrelExportsCache.get(absolutePath) || [];
        const cycleModule = hasCycleThroughBarrel(currentFile, exports);
        if (cycleModule) {
          return `${currentFile} → ${absolutePath} → ${cycleModule} → ${absolutePath} → ${currentFile}`;
        }
      }

      // Check bidirectional cycle (A -> B and B -> A)
      if (hasBidirectionalCycle(currentFile, absolutePath)) {
        return `${currentFile} → ${absolutePath} → ${currentFile}`;
      }

      // Check longer cycles via DFS
      const cycle = detectCycle(currentFile, new Set(), new Set(), []);
      if (cycle && cycle.length > 0) {
        return cycle.join(" → ");
      }

      return null;
    }

    // ========================================================================
    // Return visitor
    // ========================================================================

    return {
      ImportDeclaration: checkImport,
      ExportNamedDeclaration: checkImport,
      ExportAllDeclaration: checkImport,
    };
  },
};

export { noCycle };
